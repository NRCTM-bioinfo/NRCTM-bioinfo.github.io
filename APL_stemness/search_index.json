[["index.html", "APL stemness Chapter 1 Introduction", " APL stemness Yu-Ting Dai, Wen Jin 2023-03-06 Chapter 1 Introduction Acute Promyelocytic Leukemia (APL), which is a subtype of acute myeloid leukemia (AML), is characterized by the accumulation of immature cells called promyelocytes in the bone marrow and blood. APL is caused by a specific genetic abnormality, a translocation between chromosomes 15 and 17, which results in the formation of a fusion gene between the promyelocytic leukemia (PML) gene on chromosome 15 and the retinoic acid receptor alpha (RARÎ±) gene on chromosome 17. This fusion gene disrupts normal cellular processes, leading to the development of leukemia. "],["scrna-seq.html", "Chapter 2 scRNA-seq 2.1 Load packages 2.2 Pre-processing 2.3 Quaility control 2.4 Clustering 2.5 Cell annotation 2.6 Cell signature", " Chapter 2 scRNA-seq 2.1 Load packages suppressMessages({ library(dplyr) library(e1071) library(pheatmap) library(ggplot2) library(DESeq2) library(openxlsx) library(dendextend) library(matrixStats) library(ggpubr) library(limma) library(randomForest) library(clusterProfiler) library(genefilter) library(GSVA) library(Biobase) library(org.Hs.eg.db) library(ggplot2) library(ggthemes) library(enrichplot) library(GSEABase) }) 2.2 Pre-processing # Pre-processing data was performed using cellranger cellranger count --id=${Sample_ID} \\ --fastqs=${FASTQ} \\ --sample=${Sample_ID}\\ --transcriptome=${index_path} # The single-cell based count matrix was generated and merged using Seurat apl &lt;- CreateSeuratObject(counts = apl.data, project = &quot;apl&quot;, min.cells = 0, min.features = 0) apl[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(apl, pattern = &quot;^MT-&quot;) 2.3 Quaility control # Pre-processing data was performed using Seurat apl &lt;- subset(apl, subset = nFeature_RNA &gt; 300 &amp; percent.mt &lt; 10 &amp; nCount_RNA &lt; 30000 &amp; nCount_RNA &gt; 500 &amp; Doublet == FALSE ) 2.4 Clustering # The dimensionality reduction and clustering were performed using Seurat. apl &lt;- NormalizeData(apl, normalization.method = &quot;LogNormalize&quot;, scale.factor = ncol(apl) ) apl &lt;- FindVariableFeatures(apl, selection.method = &quot;vst&quot;, nfeatures = 3000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(apl), 10) # Scale data apl &lt;- ScaleData(apl, features = VariableFeatures(apl)) apl &lt;- RunPCA(apl, features = VariableFeatures(object = apl)) # Batch effect adjustment apl &lt;- RunHarmony(apl, &quot;Sample&quot;, max.iter.harmony = 5) apl &lt;- FindNeighbors(apl, reduction = &quot;harmony&quot;, dims = 1:30) apl &lt;- FindClusters(apl, resolution = 1) apl &lt;- RunTSNE(apl, reduction = &quot;harmony&quot;, dims = 1:30, perplexity = 50) apl &lt;- RunUMAP(apl, reduction = &quot;harmony&quot;, dims = 1:30) 2.5 Cell annotation We use SingleR to provide cell type annotation. ref &lt;- readRDS(file = &quot;SingleR/hs.BlueprintEncodeData.RDS&quot;) pred.BlueprintEncodeData &lt;- SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.main) ref &lt;- readRDS(file = &quot;SingleR/hs.HumanPrimaryCellAtlasData.RDS&quot;) pred.HumanPrimaryCellAtlasData &lt;- SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.main) ref &lt;- readRDS(file = &quot;SingleR/ImmGenData.RDS&quot;) pred.ImmGenData &lt;- SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.main) ref &lt;- readRDS(file = &quot;SingleR/MonacoImmuneData.RDS&quot;) pred.MonacoImmuneData &lt;- SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.main) ref &lt;- readRDS(file = &quot;SingleR/NovershternHematopoieticData.RDS&quot;) pred.NovershternHematopoieticData &lt;- SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.main) We have also generated the in-house annotation reference for APL cell population identification. This step was performed using SingleR. ref &lt;- readRDS(file = &quot;data/APL_SingleR_reference_Log.rds&quot;) pred.APL &lt;- SingleR::SingleR(test = apl@assays$RNA@data, ref = ref, labels = ref$label.fine) pred.APL %&gt;% head() 2.6 Cell signature The cell signature matrix for each branch in APL was generated using CIBERSORTx (https://cibersortx.stanford.edu/runcibersortx.php) apl.signature &lt;- read.table(&quot;data/CIBERSORTx_sig_1w_branch_mix_out.txt&quot;, header = T, row.names = 1) apl.signature %&gt;% dim() ## [1] 3388 9 apl.signature %&gt;% head() ## Stem_like CMP_like S100_GMP_like GMP_like Cycling_GMP_like MDP_like Bcell Tcell Ery_HBB ## A1BG 7.730646 7.750874 7.779596 8.062909 7.437444 7.573643 7.260941 0 0.000000 ## A4GALT 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0 5.027246 ## AAR2 5.403863 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0 0.000000 ## AARSD1 5.617030 6.051531 0.000000 0.000000 5.715844 0.000000 0.000000 0 0.000000 ## AASDHPPT 6.151580 6.168110 0.000000 0.000000 6.213959 0.000000 0.000000 0 0.000000 ## ABCB10 0.000000 0.000000 0.000000 0.000000 5.672631 0.000000 0.000000 0 8.247811 pheatmap(as.matrix(apl.signature), scale = &quot;row&quot;, color = colorRampPalette(c(&quot;#1B3361&quot;,&quot;#76C7FF&quot;,&quot;#FFFFFF&quot;,&quot;#FF987A&quot;,&quot;#6A0D28&quot;))(501), cluster_row = T, cluster_col = T, border_color = NA, clustering_distance_rows = &quot;manhattan&quot;, clustering_distance_cols = &quot;manhattan&quot;, clustering_method = &quot;ward.D&quot;, fontsize_col = 10, fontsize_row = 0.1) "],["bulk.html", "Chapter 3 Bulk 3.1 Pre-processing 3.2 DEGs", " Chapter 3 Bulk 3.1 Pre-processing In bulk RNA-seq analysis, Salmon was used to generate the count and transcripts per kilobase of exon model per million mapped reads (TPM) matrix. For normalization of the count matrix, we used DESeq2 to transform count matrix via varianceStabilizingTransformation. The limma package was used to calculate differentially expressed genes (DEGs) with significance level setting as adjusted P-value &lt; 0.05 and log2FC &gt; 0.58 or &lt; -0.58 (Log2 Fold change 1.5). # Pre-processing of bulk RNA-seq data was performed using salmon gtf_file=${hg38}/gencode.v38.annotation.gtf out_path=${out_path} salmon_index=${salmon_index} $SALMON quant -p 8 -l IU -i ${salmon_index} -o ${out_path}/${id} -1 ${fq1} -2 ${fq2} -g ${gtf_file} --gcBias --validateMappings Then the TPM and count matrices were generated. # read count data using DESeq2 ddsHTSeq &lt;- DESeqDataSetFromMatrix(countData = exp.count, DataFrame(condition), ~ condition) dds &lt;- DESeq(ddsHTSeq) dds.vsd &lt;- varianceStabilizingTransformation(dds, blind = TRUE) exp.vst &lt;- assay(dds.vsd) exp.vst &lt;- exp.vst - min(exp.vst) 3.2 DEGs pdata &lt;- meta.data pdata$con &lt;- meta.data$EarlyDeath design &lt;- model.matrix(~ 0 + as.factor(con), data = pdata) colnames(design) &lt;- str_replace_all(colnames(design), fixed(&quot;as.factor(con)&quot;), &quot;&quot;) fit &lt;- lmFit(exp.vst[, pdata$ID], design) # make contrast contrast &lt;- makeContrasts(ED = ED - Alive, levels = design) fits &lt;- contrasts.fit(fit, contrast) ebFit &lt;- eBayes(fits) deg.data &lt;- deg_sig_list[which(!is.na(deg_sig_list$adj.P.Val)), ] deg.data$logP &lt;- -log10(deg.data$adj.P.Val) deg.data$group = &quot;zz&quot; deg.data$group[which( (deg.data$adj.P.Val &lt; 0.05) &amp; (deg.data$logFC &gt; 0) )] = &quot;up&quot; deg.data$group[which( (deg.data$adj.P.Val &lt; 0.05) &amp; (deg.data$logFC &lt; -0) )] = &quot;down&quot; deg.data$tag &lt;- paste0(&quot;ED - Alive&quot;) deg.data$Gene &lt;- rownames(deg.data) "],["deconvolution.html", "Chapter 4 Deconvolution 4.1 SVR 4.2 Regression", " Chapter 4 Deconvolution 4.1 SVR deconvolution &lt;- function(exp.mat, sig.mat, ncores) { merge.mat &lt;- list(y = as.matrix(exp.mat[rownames(sig.mat), ]), x = as.matrix(sig.mat) ) nu &lt;- c(0.25, 0.5, 0.75, 1) res &lt;- parallel::mclapply(seq_len(ncol(merge.mat$y)), function(z) { lapply(nu, function(i) { suppressMessages( suppressWarnings( svm(x = merge.mat$x, y = as.vector(merge.mat$y[,z]), nu = i, type = &#39;nu-regression&#39;, scale = FALSE, kernel = &#39;linear&#39;) )) }) }, mc.cores = ncores) rmse &lt;- lapply(res, function(z) { lapply(z, function(i){ sqrt(sum(i$residuals ^ 2)/length(i$residuals)) }) }) rmse &lt;- unlist(lapply(rmse, function(z) which.min(unlist(z)))) # extract models with min rmse mod &lt;- lapply(seq_along(res), function(z) {res[[z]][[rmse[z]]] }) # return coefficients coefs &lt;- lapply(mod, function(z) {as.numeric(t(z$coefs) %*% z$SV)}) coefs &lt;- as.data.frame(t(data.frame(coefs))) rownames(coefs) &lt;- colnames(merge.mat$y) colnames(coefs) &lt;- colnames(merge.mat$x) return(coefs) } ## Read expression data exp.tpm &lt;- readRDS(&quot;data/test_sample.deconvolution.TPM.rds&quot;) ## Read APL cell signature apl.signature &lt;- read.table(&quot;data/CIBERSORTx_sig_1w_branch_mix_out.txt&quot;, header = T, row.names = 1) exp.tpm %&gt;% dim() ## [1] 59059 4 exp.tpm %&gt;% head() ## Sample1_D0 Sample1_D2 Sample2_D0 Sample2_D2 ## MT-TP 0.000000 0.000000 0.000000 0.000000 ## MT-TT 0.000000 0.000000 0.000000 0.000000 ## MT-CYB 8.881261 10.365305 8.261164 7.665180 ## MT-TE 0.000000 2.038275 0.000000 0.000000 ## MT-ND5 8.482372 10.193168 7.562510 6.836126 ## MT-TH 0.000000 0.000000 0.000000 0.000000 decon.bulk &lt;- deconvolution(exp.tpm, apl.signature, 2) decon.bulk ## Stem_like CMP_like S100_GMP_like GMP_like Cycling_GMP_like MDP_like Bcell Tcell ## Sample1_D0 0.07529567 0.10350092 0.03448240 0.11317247 0.07242141 -0.036336654 -0.001332079 -0.01107926 ## Sample1_D2 0.02475704 0.09213044 0.07226910 0.09549506 0.10994063 -0.020194884 -0.019769557 -0.01844252 ## Sample2_D0 0.07369273 0.08279027 0.02690492 0.09092999 0.08925341 -0.031818018 -0.011689173 -0.01151967 ## Sample2_D2 0.01215697 0.05962230 0.06167627 0.06472944 0.08228598 -0.002675738 -0.008172039 -0.01388785 ## Ery_HBB ## Sample1_D0 0.03456649 ## Sample1_D2 0.05735423 ## Sample2_D0 0.02466050 ## Sample2_D2 0.02879369 4.2 Regression # Read model linear.model &lt;- readRDS(&quot;data/PredModel.rds&quot;) branch.name &lt;- c(&quot;Stem_like&quot;,&quot;CMP_like&quot;,&quot;S100_GMP_like&quot;,&quot;GMP_like&quot;,&quot;Cycling_GMP_like&quot;,&quot;MDP_like&quot;,&quot;Bcell&quot;,&quot;Tcell&quot;,&quot;Ery_HBB&quot;) pred.score &lt;- NULL for (i in 1:length(branch.name)) { exp = as.matrix(decon.bulk[, i]) lm.model &lt;- linear.model[[i]] pred.obv &lt;- as.numeric(lm.model$coefficients[1]) + as.numeric(lm.model$coefficients[2]) * as.numeric(decon.bulk[, i]) pred.score &lt;- cbind(pred.score, pred.obv) } rownames(pred.score) &lt;- rownames(decon.bulk) colnames(pred.score) &lt;- branch.name # Coefficeint matrix pred.score ## Stem_like CMP_like S100_GMP_like GMP_like Cycling_GMP_like MDP_like Bcell Tcell Ery_HBB ## Sample1_D0 2.0158598 6.990032 22.47653 56.60889 12.89132 0.2585436 1.863082 5.170869 0.7296987 ## Sample1_D2 -0.2064932 8.106715 19.15908 51.55584 15.45176 1.0538323 2.035280 3.350186 0.9362890 ## Sample2_D0 1.9453732 9.024004 23.14179 50.25093 14.03999 0.4811723 1.959813 5.061971 0.6398924 ## Sample2_D2 -0.7605606 11.299307 20.08907 42.76156 13.56451 1.9169828 1.926964 4.476400 0.6773634 pred.percent &lt;- pred.score for (i in 1:nrow(pred.percent)) { if (sum(pred.percent[i, ] &lt; 0) &gt; 0) { pred.percent[i, ] &lt;- pred.percent[i, ] - min(pred.percent[i, ]) pred.percent[i, ] &lt;- pred.percent[i, ] / sum(pred.percent[i, ]) * 100 } else { pred.percent[i, ] &lt;- pred.percent[i, ] / sum(pred.percent[i, ]) * 100 } } # Proportion estimation pred.percent ## Stem_like CMP_like S100_GMP_like GMP_like Cycling_GMP_like MDP_like Bcell Tcell Ery_HBB ## Sample1_D0 1.849331 6.412590 20.61976 51.93246 11.82638 0.2371855 1.709173 4.743706 0.6694187 ## Sample1_D2 0.000000 8.047565 18.74675 50.10830 15.15790 1.2200524 2.170139 3.443028 1.1062652 ## Sample2_D0 1.825871 8.469670 21.72022 47.16407 13.17753 0.4516144 1.839423 4.751019 0.6005846 ## Sample2_D2 0.000000 11.731772 20.28240 42.33808 13.93535 2.6046993 2.614409 5.094486 1.3988044 "],["about-this-project.html", "Chapter 5 About this project Current version Acknowledgment Session Information", " Chapter 5 About this project Current version Version: 1.0.0 Release Date: 2023-03-04 Acknowledgment This work was supported by the XX. Session Information # Show session information sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Ventura 13.0.1 ## ## Matrix products: default ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] GSEABase_1.58.0 graph_1.74.0 annotate_1.74.0 XML_3.99-0.12 ## [5] enrichplot_1.16.2 ggthemes_4.2.4 org.Hs.eg.db_3.15.0 AnnotationDbi_1.58.0 ## [9] GSVA_1.44.5 genefilter_1.78.0 clusterProfiler_4.4.4 randomForest_4.7-1.1 ## [13] limma_3.52.4 ggpubr_0.5.0 dendextend_1.16.0 openxlsx_4.2.5.1 ## [17] DESeq2_1.36.0 SummarizedExperiment_1.26.1 Biobase_2.56.0 MatrixGenerics_1.8.1 ## [21] matrixStats_0.63.0 GenomicRanges_1.48.0 GenomeInfoDb_1.32.4 IRanges_2.30.1 ## [25] S4Vectors_0.34.0 BiocGenerics_0.42.0 ggplot2_3.4.0 pheatmap_1.0.12 ## [29] e1071_1.7-12 dplyr_1.0.10 ## ## loaded via a namespace (and not attached): ## [1] shadowtext_0.1.2 backports_1.4.1 fastmatch_1.1-3 plyr_1.8.8 ## [5] igraph_1.3.5 lazyeval_0.2.2 splines_4.2.1 BiocParallel_1.30.4 ## [9] digest_0.6.30 yulab.utils_0.0.5 htmltools_0.5.3 GOSemSim_2.22.0 ## [13] viridis_0.6.2 GO.db_3.15.0 fansi_1.0.3 magrittr_2.0.3 ## [17] memoise_2.0.1 ScaledMatrix_1.4.1 Biostrings_2.64.1 graphlayouts_0.8.3 ## [21] colorspace_2.0-3 blob_1.2.3 ggrepel_0.9.2 xfun_0.35 ## [25] crayon_1.5.2 RCurl_1.98-1.9 jsonlite_1.8.3 scatterpie_0.1.8 ## [29] survival_3.4-0 ape_5.6-2 glue_1.6.2 polyclip_1.10-4 ## [33] gtable_0.3.1 zlibbioc_1.42.0 XVector_0.36.0 DelayedArray_0.22.0 ## [37] BiocSingular_1.12.0 car_3.1-1 Rhdf5lib_1.18.2 SingleCellExperiment_1.18.1 ## [41] HDF5Array_1.24.2 abind_1.4-5 scales_1.2.1 DOSE_3.22.1 ## [45] DBI_1.1.3 rstatix_0.7.1 Rcpp_1.0.9 viridisLite_0.4.1 ## [49] xtable_1.8-4 tidytree_0.4.1 gridGraphics_0.5-1 rsvd_1.0.5 ## [53] bit_4.0.5 proxy_0.4-27 httr_1.4.4 fgsea_1.22.0 ## [57] RColorBrewer_1.1-3 pkgconfig_2.0.3 farver_2.1.1 sass_0.4.2 ## [61] locfit_1.5-9.6 utf8_1.2.2 ggplotify_0.1.0 tidyselect_1.2.0 ## [65] rlang_1.0.6 reshape2_1.4.4 munsell_0.5.0 tools_4.2.1 ## [69] cachem_1.0.6 downloader_0.4 cli_3.4.1 generics_0.1.3 ## [73] RSQLite_2.2.18 broom_1.0.1 evaluate_0.18 stringr_1.4.1 ## [77] fastmap_1.1.0 yaml_2.3.6 ggtree_3.4.4 knitr_1.41 ## [81] bit64_4.0.5 tidygraph_1.2.2 zip_2.2.2 purrr_0.3.5 ## [85] KEGGREST_1.36.3 ggraph_2.1.0 sparseMatrixStats_1.8.0 nlme_3.1-160 ## [89] aplot_0.1.8 DO.db_2.9 compiler_4.2.1 rstudioapi_0.14 ## [93] png_0.1-7 ggsignif_0.6.4 treeio_1.20.2 tibble_3.1.8 ## [97] tweenr_2.0.2 geneplotter_1.74.0 bslib_0.4.1 stringi_1.7.8 ## [101] highr_0.9 lattice_0.20-45 Matrix_1.5-3 vctrs_0.5.1 ## [105] rhdf5filters_1.8.0 pillar_1.8.1 lifecycle_1.0.3 jquerylib_0.1.4 ## [109] irlba_2.3.5.1 data.table_1.14.6 bitops_1.0-7 patchwork_1.1.2 ## [113] qvalue_2.28.0 R6_2.5.1 bookdown_0.32 gridExtra_2.3 ## [117] codetools_0.2-18 MASS_7.3-58.1 assertthat_0.2.1 rhdf5_2.40.0 ## [121] withr_2.5.0 GenomeInfoDbData_1.2.8 parallel_4.2.1 beachmat_2.12.0 ## [125] grid_4.2.1 ggfun_0.0.8 tidyr_1.2.1 class_7.3-20 ## [129] DelayedMatrixStats_1.18.2 rmarkdown_2.18 carData_3.0-5 ggforce_0.4.1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
